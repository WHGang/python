@ http://coolpython.net/python_senior/index.html  
@ https://pythonav.com/  

# 什么是Python?使用Python的优点有哪些?

Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。  
优点有：简单、易学、可移植、可扩展、具有多种内建数据类型、开源等等。一个广泛的标准库

# python的基本数据类型
Python3 中有六个标准的数据类型：  
>Number（数字）  
String（字符串）  
List（列表）  
Tuple（元组）  
Set（集合）  
Dictionary（字典）  

Python3 的六个标准数据类型中：  
>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；  
可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。  

# Python中负的索引是什么意思?
Python中可以使用整数和负数进行索引。对于正索引，0是第一个，1是第二个，以此类推。对于负索引，-1是最后一个，-2是倒数第二个，以此类推。


# xrange 和range的区别
py2
> xrange 用法与 range 完全相同  
range()返回的是一个list对象;  
xrange返回的是一个生成器对象(xrange object); 
xrange()则不会直接生成一个list，而是每次调用返回其中的一个值，内存空间使用极少。因而性能非常好，所以尽量用xrange吧。

py3
> 在python3 中没有xrange，只有range。range和python2 中的xrange()一样。


# 什么是序列化（pickling）和反序列化（unpickling）?
Pickling是一个过程，其中pickle模块接受任何Python对象，将其转换为字符串表示形式，并使用dump()函数将其转储到文件中。  
unpickling是从存储的字符串表示中检索原始Python对象以供使用的过程。  
pickle是一个标准模块，用于序列化和反序列化Python对象结构。  


# 列表与元组的区别？
列表和元组之间的区别在于列表是可变的而元组不是。元组可以被散列为例如作为字典的关键。

# 继承与重用

# 参数传递是什么方式？

>python传参数是传值还是传址？  
Python中函数参数是引用传递（注意不是值传递）。   
对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；  
对于可变类型（列表、字典）来说，函数体运算可能会更改传入的参数变量。  


# 函数中修改全局变量，是否需要使用global进行申明
@ https://blog.csdn.net/weixin_43868754/article/details/105210628


# 进程和线程区别？
根本区别：进程是资源分配最小单位，线程是处理器任务调度和执行的基本单位
进程是并发执行的程序在执行过程中分配和管理资源的基本单位。线程是进程的一个执行单元，是比进程还要小的独立运行的基本单位。一个程序至少有一个进程，一个进程至少有一个线程。

# 进程通信有哪些方式？
管道、消息队列、信号量、共享内存、套接字

# 并发和并行
并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）
并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的


# 什么是可变对象，什么是不可变对象：
可变对象是指，一个对象在不改变其所指向的地址的前提下，可以修改其所指向的地址中的值；
例如：字典，集合，列表，都属于可变对象，说其可变，是指其内存中的值可变。

不可变对象是指，一个对象所指向的地址上值是不能修改的，如果你修改了这个对象的值，那么它指向的地址就改变了，相当于你把这个对象指向的值复制出来一份，然后做了修改后存到另一个地址上了，但是可变对象就不会做这样的动作，而是直接在对象所指的地址上把值给改变了，而这个对象依然指向这个地址。
例如：a = 4

# 深拷贝与浅拷贝
## 1 浅拷贝
拷贝规则如下：
> 如果被拷贝对象是不可变对象，则不会生成新的对象  
> 如果被拷贝对象是可变对象，则会生成新的对象，但是只会对可变对象最外层进行拷贝  

## 2. 深拷贝
拷贝规则:
> 如果被拷贝对象是不可变对象，深拷贝不会生成新对象，因为被拷贝对象是不可变的，继续用原来的那个，不会产生什么坏的影响  
> 如果被拷贝对象是可变对象，那么会彻底的创建出一个和被拷贝对象一模一样的新对象  




# python内存管理
>在python中维护了一个refchain的双向环状链表，这个链表中存储程序创建的所有对象，每种类型的对象逗游一个ob_refcnt引用计数器的值，最后当引用计数器为0时会进行垃圾回收。  
 但是，在python中对于那些可以有 多个元素组成的对象可能存在循环引用的问题，为了解决这个问题。引入了标记清楚和分代回收。
# 引用
在 Python 中，变量也称为对象的引用。因为变量存储的就是对象的地址。变量通过地址引用了“对象”。
变量位于栈内存（压栈出栈等）。
对象位于堆内存。

# python的垃圾回收机制：引用计数，标记清除，分代回收
@ https://www.bilibili.com/video/av540519616?p=3  
@ https://www.bilibili.com/video/av63471671/  

## 1. 引用计数
typedef struct_object{  
    int ob_refcnt;  
    struct_typeobject *ob_type;  
}PyObject;       
每个对象中都包含PyObject结构体(上一个对象，下一个对象，变量类型，引用计数器)。  
有多个元素组成的对象：PyObject + PyVarObject(元素个数)。    
其中ob_refcnt就是做为引用计数。当有其他变量引用该对象时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少，当ob_refcnt=0时，这个对象的生命就结束了,这时，垃圾回收机制就会启动将这个对象回收。      

引用计数的优点  
> 简单      
> 实时性高，只要引用计数为0，对象就会被销毁，内存被释放，回收内存的的时间平摊到了平时。  
> 
引用计数的缺点    
> 为了维护引用计数消耗了很多资源  
> 循环引用，循环引用导致内存泄漏，例如下面的代码  

## 2. 标记清除
标记清除可以处理这种循环引用的情况  
可能存在循环引用的对象：列表、元祖、字典、集合
扫描可能存在循环引用的对象，检查是否存在循环应用，如果有，则让双方引用计数器-1，如果是0则进行垃圾回收。


## 3. 分代回收
    分代回收建立标记清除的基础之上，是一种以空间换时间的操作方式。标记清除可以回收循环引用的垃圾，但是，回收的频次是需要控制的，如果时时刻刻做标记清除，可以想象，python的程序会慢成什么样子。

    分代回收，根据内存中对象的存活时间将他们分为3代，新生的对象放入到0代，如果一个对象能在第0代的垃圾回收过程中存活下来，GC就会将其放入到1代中，如果1代里的对象在第1代的垃圾回收过程中存活下来，则会进入到2代。

分代回收的触发机制   
import gc  
print(gc.get_threshold())   
上面的代码执行结果是(700, 10, 10)   

>当分配对象的个数减去释放对象的个数的差值大于700时，就会产生一次0代回收  
10次0代回收会导致一次1代回收  
10次1代回收会导致一次2代回收   

对于第0代的对象来说，他们很可能就被使用一次，因此需要经常被回收。

经过一轮一轮的回收后，能够活着成为第2代的对象，必然是那些使用频繁的对象，而且他们已经存活很久的时间了，大概率的，还会存活很久，因此，2代回收的就不那么频繁，

你可以通过设置这三个阈值，来改变分代回收的触发条件

import gc

gc.set_threshold(600, 10, 5)
print(gc.get_threshold())
经过了上面的设置，0代和2代的回收会更加频繁


## 缓存机制
如果对象频繁的创建和销毁，就会产生很多内存碎片，最终会影响的系统的性能。  
@https://pythonav.com/wiki/detail/6/88/#1.3%20%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4&%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6
1. 小整数对象
   小数据池范围：-5 <= value < 257。即：重复使用这个范围的整数时，不会重新开辟内存。


2. 字符串驻留
   Python内部还对字符串做了驻留机制，针对那么只含有字母、数字、下划线的字符串

3. list类型
   维护的free_list数组最多可缓存80个list对象。

4. tuple类型
   维护一个free_list数组且数组容量20，数组中元素可以是链表且每个链表最多可以容纳2000个元组对象。元组的free_list数组在存储数据时，是按照元组可以容纳的个数为索引找到free_list数组中对应的链表，并添加到链表中。

5. dict类型
   维护的free_list数组最多可缓存80个dict对象。


# numpy
# python用什么库实现矩阵乘法（numpy里面的不同库对比一下，matmul，dot等）
@ https://www.cnblogs.com/hezhiyao/p/8177832.html
## 一.  np.dot()  dot product.
1.同线性代数中矩阵乘法的定义。np.dot(A, B)表示：
对二维矩阵，计算真正意义上的矩阵乘积。
对于一维矩阵，计算两者的内积。

## 二. np.multiply()或 *  英[ˈmʌltɪplaɪ]
1.在Python中，实现对应元素相乘（element-wise product），有2种方式，

一个是np.multiply()
另外一个是 *

## 三、np.dot与np.matmul的区别   matrix multiplication
1.二者都是矩阵乘法。
2.np.matmul中禁止矩阵与标量的乘法。


# python 的随机数生成
@https://blog.csdn.net/qq_32618817/article/details/80583746
random模块

1. random.random()
功能：随机生成一个 [0,1) 的浮点数

2. random.randint(a,b)   
功能：生成在[int a,int b] 中的任一整数

3. random.uniform(a,b)
功能：随机生成一个 [a,b) 的浮点数

4. random.choice(sequence)
功能：从一个已有的sequence中随机选择一个元素


# python四舍五入
Python2中：  
round()的结果就是我们所理解的四舍五入，round(1.5)=2，round(2.5)=3。

Python3中：  
对round()函数有较大改动，例如round(1.5)=2，而round(2.5)却等于2，只有round(2.6)才等于3，这是为什么呢？

原来Python2中的round()是四舍五入，而到了3，round()就变成了“四舍六入五成双”。
五成双的意思是，高位为单数则进1凑成双数，高位为双数则不进位
round(1.5)=2
round(2.5)=2

当指定取舍的小数点位数的时候，如果要取舍的位数前的小数是奇数，则直接舍弃，如果是偶数则向上取舍。
round(2.775, 2) = 2.77
round(2.776, 2) = 2.78
round(2.785, 2) = 2.79



python 监测的什么数据             1111111111111111
python 好未来具体干了啥，除了调包，还自己做了什么事情。                   111111111111111

问python多线程？

